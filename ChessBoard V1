let tileSize, board = [], currentTurn = 'w', selectedSquare = { x: -1, y: -1 }, movingPiece = null;
let legalMoves = [], legalCaptures = {}, pieceImages = {};
let checkData = { w: [], b: [] }; 
let gameOver = false, statusText = "";
let hasMoved = { wK: false, bK: false, wR0: false, wR7: false, bR0: false, bR7: false };
let promotionState = { active: false, x: -1, y: -1, color: '' };

const pieceNames = {
  'wP': 'White Pawn', 'wR': 'White Rook', 'wN': 'White Knight', 'wB': 'White Bishop', 'wQ': 'White Queen', 'wK': 'White King',
  'bP': 'Black Pawn', 'bR': 'Black Rook', 'bN': 'Black Knight', 'bB': 'Black Bishop', 'bQ': 'Black Queen', 'bK': 'Black King'
};

function preload() {
  const base = "https://raw.githubusercontent.com/lichess-org/lila/ac65212b7b0c0918190ab1c768391fe3d8520296/public/piece/chess7/"
  const pieces = ['wP', 'wR', 'wN', 'wB', 'wQ', 'wK', 'bP', 'bR', 'bN', 'bB', 'bQ', 'bK'];
  
  for (let p of pieces) {
    pieceImages[p] = loadImage(base + p + ".svg");
  }
}

function setup() {
  createCanvas(600, 600);
  tileSize = width / 8; 
  for (let x = 0; x < 8; x++) board[x] = new Array(8).fill(null);
  const layout = ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'];
  for (let i = 0; i < 8; i++) {
    board[i][0] = 'bR'; board[i][1] = 'bP';
    board[i][7] = 'wR'; board[i][6] = 'wP';
    board[i][0] = 'b' + layout[i]; board[i][7] = 'w' + layout[i];
  }
}

function draw() {
  background(240);
  for (let x = 0; x < 8; x++) {
    for (let y = 0; y < 8; y++) {
      fill((x + y) % 2 === 0 ? "#EEEED2" : "#769656");
      if (selectedSquare.x === x && selectedSquare.y === y) fill("#F7B7A3");
      if (legalMoves.some(m => m.x === x && m.y === y)) fill("#B9E391");
      noStroke(); rect(x * tileSize, y * tileSize, tileSize, tileSize);
      if (board[x][y]) image(pieceImages[board[x][y]], x * tileSize, y * tileSize, tileSize, tileSize);
      if (legalCaptures[`${x},${y}`]) {
        textAlign(CENTER, CENTER); textSize(tileSize * 0.4); text("ðŸ’€", x * tileSize + tileSize/2, y * tileSize + tileSize/2);
      }
    }
  }
  let wK = findKing('wK'), bK = findKing('bK');
  checkData.w.forEach(p => drawAssaultRifle(p.x, p.y, wK.x, wK.y));
  checkData.b.forEach(p => drawAssaultRifle(p.x, p.y, bK.x, bK.y));
  if (gameOver) drawGameOver();
  if (promotionState.active) drawPromotionMenu();
}

function getPseudoMoves(x, y, piece, b, ignoreCastling = false) {
  let moves = [], color = piece[0], type = piece[1];
  const add = (nx, ny) => {
    if (nx < 0 || nx > 7 || ny < 0 || ny > 7) return false;
    if (!b[nx][ny]) { moves.push({x: nx, y: ny}); return true; }
    if (b[nx][ny][0] !== color) { moves.push({x: nx, y: ny}); }
    return false;
  };

  if (type === 'P') {
    let d = color === 'w' ? -1 : 1;
    if (y+d >= 0 && y+d <= 7 && !b[x][y+d]) {
      moves.push({x: x, y: y+d});
      if (y === (color === 'w' ? 6 : 1) && !b[x][y+2*d] && !b[x][y+d]) moves.push({x: x, y: y+2*d});
    }
    [[-1, d], [1, d]].forEach(m => {
      let nx = x + m[0], ny = y + m[1];
      if (nx >= 0 && nx <= 7 && ny >= 0 && ny <= 7 && b[nx][ny] && b[nx][ny][0] !== color) moves.push({x: nx, y: ny});
    });
  } else if (type === 'N') {
    [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(m => add(x+m[0], y+m[1]));
  } else if (['R', 'B', 'Q'].includes(type)) {
    let dirs = [];
    if (type !== 'B') dirs.push([0,1],[0,-1],[1,0],[-1,0]);
    if (type !== 'R') dirs.push([1,1],[1,-1],[-1,1],[-1,-1]);
    dirs.forEach(d => { for (let i = 1; i < 8; i++) if (!add(x + d[0]*i, y + d[1]*i)) break; });
  } else if (type === 'K') {
    for (let dx = -1; dx <= 1; dx++) for (let dy = -1; dy <= 1; dy++) if (dx !== 0 || dy !== 0) add(x + dx, y + dy);
    
    if (!ignoreCastling) {
      let r = color === 'w' ? 7 : 0;
      if (!hasMoved[color+'K'] && getCheckingPieces(color+'K', b).length === 0) {
        if (!hasMoved[color+'R7'] && !b[5][r] && !b[6][r] && isSquareSafe(5, r, color, b)) moves.push({x: 6, y: r});
        if (!hasMoved[color+'R0'] && !b[1][r] && !b[2][r] && !b[3][r] && isSquareSafe(3, r, color, b)) moves.push({x: 2, y: r});
      }
    }
  }
  return moves;
}

function isSquareSafe(tx, ty, color, b) {
  let enemy = color === 'w' ? 'b' : 'w';
  for (let x = 0; x < 8; x++) for (let y = 0; y < 8; y++) {
    if (b[x][y] && b[x][y][0] === enemy) {
      let em = getPseudoMoves(x, y, b[x][y], b, true);
      if (em.some(m => m.x === tx && m.y === ty)) return false;
    }
  }
  return true;
}

function getStrictLegalMoves(fx, fy, p) {
  let pMoves = getPseudoMoves(fx, fy, p, board);
  legalCaptures = {};
  let finalMoves = pMoves.filter(m => {
    let old = board[m.x][m.y], res = true;
    board[m.x][m.y] = p; board[fx][fy] = null;
    if (getCheckingPieces(p[0] + 'K', board).length > 0) res = false;
    board[fx][fy] = p; board[m.x][m.y] = old;
    if (res && old && old[0] !== p[0]) legalCaptures[`${m.x},${m.y}`] = true;
    return res;
  });
  return finalMoves;
}

function executeMove(fx, fy, tx, ty) {
  let p = board[fx][fy];
  if (p[1] === 'K' && Math.abs(tx - fx) === 2) {
    let rY = p[0] === 'w' ? 7 : 0;
    if (tx === 6) { board[5][rY] = board[7][rY]; board[7][rY] = null; }
    if (tx === 2) { board[3][rY] = board[0][rY]; board[0][rY] = null; }
  }
  if (p[1] === 'K') hasMoved[p[0]+'K'] = true;
  if (p[1] === 'R') {
    if (fx === 0) hasMoved[p[0]+'R0'] = true;
    if (fx === 7) hasMoved[p[0]+'R7'] = true;
  }
  board[tx][ty] = p; board[fx][fy] = null;
  if (p[1] === 'P' && (ty === 0 || ty === 7)) {
    promotionState = { active: true, x: tx, y: ty, color: p[0] };
    resetSelection();
  } else finalizeTurn();
}

function drawAssaultRifle(px, py, kx, ky) {
  push(); translate(px * tileSize + tileSize/2, py * tileSize + tileSize/2);
  rotate(atan2(ky - py, kx - px)); if (kx < px) scale(1, -1);
  fill(40); stroke(0); rect(0, -2, 45, 4); rect(-15, -4, 20, 8); pop();
}

function drawPromotionMenu() {
  fill(0, 150); rect(0, 0, width, height);
  let pieces = ['Q', 'R', 'B', 'N'], cx = width/2 - tileSize*2, cy = height/2 - tileSize/2;
  for (let i = 0; i < 4; i++) {
    fill(255); rect(cx + i * tileSize, cy, tileSize, tileSize);
    image(pieceImages[promotionState.color + pieces[i]], cx + i * tileSize, cy, tileSize, tileSize);
  }
}

function mousePressed() {
  if (gameOver) return;
  if (promotionState.active) {
    let cx = width/2 - tileSize*2, cy = height/2 - tileSize/2;
    for (let i = 0; i < 4; i++) {
      let px = cx + i * tileSize;
      if (mouseX > px && mouseX < px + tileSize && mouseY > cy && mouseY < cy + tileSize) {
        board[promotionState.x][promotionState.y] = promotionState.color + ['Q', 'R', 'B', 'N'][i];
        promotionState.active = false; finalizeTurn();
      }
    }
    return;
  }
  let col = floor(mouseX / tileSize), row = floor(mouseY / tileSize);
  if (col < 0 || col > 7 || row < 0 || row > 7) return;
  let move = legalMoves.find(m => m.x === col && m.y === row);
  if (movingPiece && move) executeMove(selectedSquare.x, selectedSquare.y, col, row);
  else if (board[col][row] && board[col][row][0] === currentTurn) {
    movingPiece = board[col][row]; selectedSquare = { x: col, y: row };
    legalMoves = getStrictLegalMoves(col, row, movingPiece);
  } else resetSelection();
}

function finalizeTurn() { currentTurn = currentTurn === 'w' ? 'b' : 'w'; resetSelection(); updateCheckStatus(); checkGameEnd(); }
function updateCheckStatus() { checkData.w = getCheckingPieces('wK', board); checkData.b = getCheckingPieces('bK', board); }
function findKing(c) { for(let x=0; x<8; x++) for(let y=0; y<8; y++) if(board[x][y] === c) return {x, y}; return {x:-1, y:-1}; }
function resetSelection() { movingPiece = null; selectedSquare = { x: -1, y: -1 }; legalMoves = []; legalCaptures = {}; }
function drawGameOver() { fill(0, 150); rect(0, 0, width, height); fill(255); textAlign(CENTER); text(statusText, width/2, height/2); }
function getCheckingPieces(k, b) { let kP = findKing(k), enemy = k[0] === 'w' ? 'b' : 'w', c = []; if (kP.x === -1) return []; for(let x=0; x<8; x++) for(let y=0; y<8; y++) if(b[x][y] && b[x][y][0] === enemy && getPseudoMoves(x, y, b[x][y], b, true).some(m => m.x === kP.x && m.y === kP.y)) c.push({x, y}); return c; }
function checkGameEnd() { let h = false; for (let x = 0; x < 8; x++) for (let y = 0; y < 8; y++) if (board[x][y] && board[x][y][0] === currentTurn && getStrictLegalMoves(x, y, board[x][y]).length > 0) h = true; if (!h) { gameOver = true; statusText = getCheckingPieces(currentTurn + 'K', board).length > 0 ? (currentTurn === 'w' ? "Black Wins!" : "White Wins!") : "Draw"; } }
